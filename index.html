<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" >
<!-- 2020 David DiPaola. Licensed under CC0 (https://creativecommons.org/share-your-work/public-domain/cc0/). -->
<script>
/* @license magnet:?xt=urn:btih:90dc5c0be029de84e523b9b3922520e79e0e6f08&dn=cc0.txt CC0 */

let util = {
	hex32: function hex32(val) {
		/* TODO might need optimization */
		return ("00000000" + val.toString(16)).substr(-8).toUpperCase();
	},

	signExtend: function signExtend(width, val) {
		let msb = (1 << (width - 1));
		if (val & msb) {
			val -= (msb * 2);
		}

		return val;
	},

	getElem: function getElem(id) {
		let elem = null;
		if ((typeof id) === "string") {
			elem = document.getElementById(id);
		}
		else if (id instanceof HTMLElement) {
			elem = id;
		}
		else {
			throw new Error("can't use ID " + id + " to find an element");
		}

		if (!elem) {
			throw new Error("can't find element with ID " + id);
		}

		return elem;
	},

	getEventable: function getEventable(id) {
		let elem = null
		if ((typeof id) === "string") {
			elem = util.getElem(id);
		}
		else if ((typeof id.addEventListener) === "function") {
			elem = id;
		}
		else {
			throw new Error("can't use ID " + id + " to find an element");
		}

		if (!elem) {
			throw new Error("can't find element with ID " + id);
		}

		return elem;
	},

	setOnClick: function setOnClick(id, func) {
		util.getEventable(id).addEventListener("click", func);
	},

	setOnChange: function setOnChange(id, func) {
		util.getEventable(id).addEventListener("change", func);
	},

	setOnKeydown: function setOnKeydown(id, func) {
		util.getEventable(id).addEventListener("keydown", func);
	},
};

let mem = {
	ram: null,
	ram_size: 1 * 1024 * 1024,

	init: function init() {
		this.ram = new Uint32Array(this.ram_size / 4);
	},

	load: function load(buffer) {
		/* TODO test on big endian system */
		const input = new Uint8Array(buffer);
		const input_length_rounded = input.length & ~0b11;
		for (let i=0; i<input_length_rounded; i+=4) {
			this.ram[i / 4] = (
				(input[i+0] <<  0) |
				(input[i+1] <<  8) |
				(input[i+2] << 16) |
				(input[i+3] << 24)
			);
		}
		let diff = input.length - input_length_rounded;
		if (diff > 0) {
			console.log("WARNING: binary size is not aligned! Ignoring final "+diff+" bytes.");
		}
	},

	read: function read(address) {
		if (address == 0xFF004) {
			return serial.input.getCode();
		}
		else {
			return this.ram[address / 4];
		}
	},

	write: function write(address, data) {
		this.ram[address / 4] = data;

		if ((address >= 0xFB000) && (address <= 0xFEFFF)) {
			screen.update(address - 0xFB000, data);
		}
		else if (address == 0xFF008) {
			return serial.output.putCode(data);
		}
	},

	// TODO button to reset memory back to state after assemble/load
};

let cpu = {
	pc: 0,
	x: null,
	breakSet: false,
	haltSet: false,
	stepInterval: null,

	init: function init() {
		this.x = new Uint32Array(16);

		this.reset();
	},

	intervalStart: function intervalStart() {
		if (!this.stepInterval) {
			let self = this;
			function stepMultiple() {
				for (let i=0; i<10; i++) {
					self.step();
					if (self.breakSet || self.haltSet) {
						ui.update();
						break;
					}
				}
			}
			this.stepInterval = setInterval(stepMultiple, 1);
		}
	},

	intervalStop: function intervalStop() {
		if (this.stepInterval) {
			clearInterval(this.stepInterval);
			this.stepInterval = null;
		}
	},

	reset: function reset() {
		this.intervalStop();

		this.pc = 0;
		for (let i=0; i<this.x.length; i++) {
			this.x[i] = 0;
		}

		this.breakSet = false;
		this.haltSet = false;
	},

	run: function run() {
		this.breakSet = false;

		this.intervalStart();
	},

	brk: function brk() {
		this.intervalStop();

		this.breakSet = true;
	},

	halt: function halt() {
		this.intervalStop();

		this.haltSet = true;
	},

	decode: {
		// TODO handle registers >15

		r: function r(instr) {
			return {
				type: "r",
				rd:     (instr >>  7) &   0b01111,
				funct3: (instr >> 12) &     0b111,
				rs1:    (instr >> 15) &   0b01111,
				rs2:    (instr >> 20) &   0b01111,
				funct7: (instr >> 25) & 0b1111111,
			};
		},

		i: function i(instr) {
			return {
				type: "i",
				rd:     (instr >>  7) &        0b01111,
				funct3: (instr >> 12) &          0b111,
				rs1:    (instr >> 15) &        0b01111,
				imm:    (instr >> 20) & 0b111111111111,
			};
		},

		s: function s(instr) {
			return {
				type: "s",
				imm:    (((instr >> 25) & 0b1111111) << 5) | ((instr >> 7) & 0b11111),
				funct3: (instr >> 12) &   0b111,
				rs1:    (instr >> 15) & 0b01111,
				rs2:    (instr >> 20) & 0b01111,
			};
		},

		b: function b(instr) {
			let imm = (((instr >> 31) & 0b1) << 12) | (((instr >> 7) & 0b1) << 11) | (((instr >> 25) & 0b111111) << 5) | (((instr >> 8) & 0b1111) << 1);

			return {
				type: "b",
				imm:    util.signExtend(13, imm),
				funct3: (instr >> 12) &   0b111,
				rs1:    (instr >> 15) & 0b01111,
				rs2:    (instr >> 20) & 0b01111,
			};
		},

		u: function u(instr) {
			return {
				type: "u",
				rd:  (instr >>  7) &                0b01111,
				imm: (instr >> 12) & 0b11111111111111111111,
			};
		},

		j: function j(instr) {
			let imm = (((instr >> 31) & 0b1) << 20) | (((instr >> 12) & 0b11111111) << 12) | (((instr >> 20) & 0b1) << 11) | (((instr >> 21) & 0b1111111111) << 1);

			return {
				type: "j",
				rd:  (instr >> 7) & 0b01111,
				imm: util.signExtend(21, imm),
			};
		},
	},

	decodeError: function decodeError(dec) {
		if (typeof dec === "object") {
			let name = "";
			switch (dec.type) {
			case "r":
				name = "R-type";
				break;
			case "i":
				name = "I-type";
				break;
			case "s":
				name = "S-type";
				break;
			case "b":
				name = "B-type";
				break;
			case "u":
				name = "U-type";
				break;
			case "j":
				name = "J-type";
				break;
			}
			console.log("ERROR: unknown "+name+" instruction: " + JSON.stringify(dec));
		}
		else if (typeof dec === "number") {
			console.log("ERROR: unknown instruction " + util.hex32(dec) + "\n" +
				"R-type? " + JSON.stringify(this.decode.r(dec)) + "\n" +
				"I-type? " + JSON.stringify(this.decode.i(dec)) + "\n" +
				"S-type? " + JSON.stringify(this.decode.s(dec)) + "\n" +
				"B-type? " + JSON.stringify(this.decode.b(dec)) + "\n" +
				"U-type? " + JSON.stringify(this.decode.u(dec)) + "\n" +
				"J-type? " + JSON.stringify(this.decode.j(dec)) + "\n"
			);
		}
		else {
			console.log("ERROR: unknown instruction: " + JSON.stringify(dec));
		}

		console.trace();

		this.halt();
	},

	step: function step() {
		if (this.haltSet) {
			return;
		}

		const instr = mem.read(this.pc);

		// TODO error messages for invalid instructions
		let wasJump = false;
		let dec = instr;
		const opcode = instr & 0b1111111;
		//console.log("addr: 0x" + util.hex32(this.pc) + " instr: 0x" + instr.toString(16) + " opcode: 0b" + opcode.toString(2));
		switch (opcode) {
		case 0b0110011:  // arithmetic instructions (R-type)
			dec = this.decode.r(instr);
			switch (dec.funct3) {
			case 0x0:
				switch (dec.funct7) {
				case 0x00:  // add
					this.x[dec.rd] = this.x[dec.rs1] + this.x[dec.rs2];
					break;
				case 0x20:  // sub
					this.x[dec.rd] = this.x[dec.rs1] + this.x[dec.rs2];
					break;
				default:
					this.decodeError(dec);
					break;
				}
				break;
			case 0x4:  // xor TODO test
				this.x[dec.rd] = this.x[dec.rs1] ^ this.x[dec.rs2];
				break;
			case 0x6:  // or TODO test
				this.x[dec.rd] = this.x[dec.rs1] | this.x[dec.rs2];
				break;
			case 0x7:  // or TODO test
				this.x[dec.rd] = this.x[dec.rs1] & this.x[dec.rs2];
				break;
			case 0x1:  // sll (shift left logical) TODO test
				this.x[dec.rd] = this.x[dec.rs1] << this.x[dec.rs2];
				break;
			case 0x5:
				switch (dec.funct7) {
				case 0x00:  // srl (shift right logical) TODO test
					this.x[dec.rd] = this.x[dec.rs1] >> this.x[dec.rs2];
					break;
				case 0x20:  // sra (shift right arithmetic) TODO msb, test
					this.x[dec.rd] = this.x[dec.rs1] >> this.x[dec.rs2];
					break;
				default:
					this.decodeError(dec);
					break;
				}
				break;
			case 0x2:  // slt (set less than) TODO test
				this.x[dec.rd] = this.x[dec.rs1] < this.x[dec.rs2] ? 1 : 0;
				break;
			case 0x3:  // stlu (set less than unsigned) TODO test
				this.x[dec.rd] = this.x[dec.rs1] < this.x[dec.rs2] ? 1 : 0;
				break;
			default:
				this.decodeError(dec);
				break;
			}
			break;
		case 0b0010011:  // arithmetic immediate instructions (I-type)
			dec = this.decode.i(instr);
			switch (dec.funct3) {
			case 0x0:  // addi (add immediate)
				this.x[dec.rd] = this.x[dec.rs1] + dec.imm;
				break;
			case 0x4:  // xori (xor immediate) todo test
				this.x[dec.rd] = this.x[dec.rs1] ^ dec.imm;
				break;
			case 0x6:  // ori (or immediate) todo test
				this.x[dec.rd] = this.x[dec.rs1] | dec.imm;
				break;
			case 0x7:  // andi (and immediate) todo test
				this.x[dec.rd] = this.x[dec.rs1] & dec.imm;
				break;
			case 0x1:  // slli (shift left logical immediate) todo test
				this.x[dec.rd] = this.x[dec.rs1] << (dec.imm & 0b11111);
				break;
			case 0x5:
				switch (dec.imm >> 5) {
				case 0x00:  // srli (shift right logical immediate) todo test
					this.x[dec.rd] = this.x[dec.rs1] >> (dec.imm & 0b11111);
					break;
				case 0x20:  // srai (shift right arithmetic immediate) todo do msb, test
					this.x[dec.rd] = this.x[dec.rs1] >> (dec.imm & 0b11111);
					break;
				default:
					this.decodeError(dec);
					break;
				}
				break;
			case 0x2: // slti (set less than immediate) todo do msb, test
				this.x[dec.rd] = this.x[dec.rs1] < dec.imm ? 1 : 0;
				break;
			case 0x3: // sltiu (set less than immediate unsigned) todo do msb, test
				this.x[dec.rd] = this.x[dec.rs1] < dec.imm ? 1 : 0;
				break;
			default:
				this.decodeError(dec);
				break;
			}
			break;
		case 0b0000011:  // load instructions (I-type)
			dec = this.decode.i(instr);
			/* TODO is imm signed? */
			switch (dec.funct3) {
			case 0x0:  // lb (load byte)
				this.x[dec.rd] = mem.read(this.x[dec.rs1] + dec.imm) & 0xFF;  // TODO sign extend, test
				break;
			case 0x1:  // lh (load half-word)
				this.x[dec.rd] = mem.read(this.x[dec.rs1] + dec.imm) & 0xFFFF;  // TODO sign extend, test
				break;
			case 0x2:  // lw (load word)
				this.x[dec.rd] = mem.read(this.x[dec.rs1] + dec.imm);  // TODO test
				break;
			case 0x4:  // lbu (load byte unsigned)
				this.x[dec.rd] = mem.read(this.x[dec.rs1] + dec.imm) & 0xFF;  // TODO test
				break;
			case 0x5:  // lh (load half-word unsigned)
				this.x[dec.rd] = mem.read(this.x[dec.rs1] + dec.imm) & 0xFFFF;  // TODO test
				break;
			default:
				this.decodeError(dec);
				break;
			}
			break;
		case 0b0100011:  // store instructions (S-type)
			dec = this.decode.s(instr);
			let addr = this.x[dec.rs1] + dec.imm;
			let data = this.x[dec.rs2];
			switch (dec.funct3) {
			case 0x0:  // sb (store byte)
				mem.write(addr, data & 0xFF);  // TODO what about mem [31:8]?, test
				break;
			case 0x1:  // sh (store half)
				mem.write(addr, data & 0xFFFF);  // TODO what about mem [31:16]?, test
				break;
			case 0x2:  // sw (store word)
				mem.write(addr, data);  // TODO test
				break;
			default:
				this.decodeError(dec);
				break;
			}
			break;
		case 0b1100011:  // branch instructions (B-type)
			dec = this.decode.b(instr);
			switch (dec.funct3) {
			case 0x0:  // beq (branch if equal)
				// TODO test
				if (this.x[dec.rs1] == this.x[dec.rs2]) {
					this.pc += dec.imm;
					wasJump = true;
				}
				break;
			case 0x1:  // bne (branch if not equal)
				// TODO test
				if (this.x[dec.rs1] != this.x[dec.rs2]) {
					this.pc += dec.imm;
					wasJump = true;
				}
				break;
			case 0x4:  // blt (branch if less than)
				// TODO test
				if (this.x[dec.rs1] < this.x[dec.rs2]) {
					this.pc += dec.imm;
					wasJump = true;
				}
				break;
			case 0x5:  // bge (branch if greater than or equal)
				// TODO test
				if (this.x[dec.rs1] >= this.x[dec.rs2]) {
					this.pc += dec.imm;
					wasJump = true;
				}
				break;
			default:
				this.decodeError(dec);
				break;
			}
			break;
		case 0b1101111:  // jal (jump and link) instruction (J-type)
			dec = this.decode.j(instr);
			this.x[dec.rd] = this.pc + 4;
			this.pc += dec.imm;
			wasJump = true;
			break;
		case 0b1100111:  // jump and link instructions (I-type)
			dec = this.decode.i(instr);
			switch (dec.funct3) {
			case 0x0:  // jalr (jump and link with register)
				this.x[dec.rd] = this.pc + 4;
				this.pc = this.x[dec.rs1] + util.signExtend(12, dec.imm);
				wasJump = true;
				break;
			default:
				this.decodeError(dec);
				break;
			}
			break;
		case 0b0110111:  // lui (load upper immediate) instruction (U-type)
			// TODO test
			dec = this.decode.u(instr);
			this.x[dec.rd] = dec.imm << 12;
			break;
		case 0b0010111:  // auipc (add upper immediate to PC) instruction (U-type)
			// TODO test
			dec = this.decode.u(instr);
			this.x[dec.rd] = this.pc + (dec.imm << 12);
			break;
		case 0b1110011:  // debugging instructions
			// todo ecall vs ebreak
			console.log("break!");
			this.brk();
			break;
		default:
			this.decodeError(dec);
			break;
		}

		// TODO handle writes to x0 properly
		this.x[0] = 0;

		if (!wasJump && !this.breakSet && !this.haltSet) {
			this.pc += 4;
		}
	},
};

let screen = {
	canvas: null,
	context: null,
	width: 0,
	height: 0,

	init: function init() {
		this.canvas = util.getElem("screen_canvas");

		this.width = this.canvas.width;
		this.height = this.canvas.height;

		this.context = this.canvas.getContext("2d");

		this.reset();
	},

	reset: function reset() {
		this.imgd = this.context.createImageData(this.width, this.height);

		this.context.clearRect(0, 0, this.width, this.height);
	},

	update: function update(offset, value) {
		this.imgd.data[offset+0] = (value>>16) & 0xFF;
		this.imgd.data[offset+1] = (value>> 8) & 0xFF;
		this.imgd.data[offset+2] = (value>> 0) & 0xFF;
		this.imgd.data[offset+3] = 0xFF;

		this.context.putImageData(this.imgd, 0, 0);
	},
};

let serial = {
	output: {
		putCode: function putCode(code) {
			ui.serial.output.putChar(String.fromCharCode(code));
		},
	},

	input: {
		fifoBuffer: [],

		reset: function reset() {
			this.fifoBuffer = [];
		},

		putStr: function putStr(str) {
			for (let ch of str) {
				this.fifoBuffer.push(ch.charCodeAt(0));
			}
		},

		getCode: function getCode() {
			let code = 0;

			if (this.fifoBuffer.length > 0) {
				code = this.fifoBuffer.shift();
			}

			return code;
		},

		getFifoStr: function getFifoStr() {
			let str = "";

			for (let code of this.fifoBuffer) {
				str += String.fromCharCode(code);
			}

			return str;
		},
	},

	reset: function reset() {
		this.input.reset();
	},
};

let code = {
	// TODO assembler
};

let ui = {
	ready: false,

	init: function init() {
		this.serial.init();
		this.code.init();
		this.debug.init();
		this.mem.init();

		let self = this;
		util.setOnKeydown(window, function onWindowKeydown(kde) {
			switch (kde.key) {
			case "F1":  // mem previous block
				kde.preventDefault();
				self.mem.blockPrev();
				break;
			case "F2":  // mem next block
				kde.preventDefault();
				self.mem.blockNext();
				break;
			case "F4":  // load
				kde.preventDefault();
				ui.mem.load();
				break;
			case "F5":  // run
				kde.preventDefault();
				self.debug.run();
				break;
			case "F8":  // break
				kde.preventDefault();
				self.debug.brk();
				break;
			case "F9":  // reset
				kde.preventDefault();
				self.debug.reset();
				break;
			case "F10":  // step over
				kde.preventDefault();
				console.log("TODO step over key handler");
				break;
			case "F11":  // step into
				kde.preventDefault();
				self.debug.stepInto();
				break;
			}
		});

		this.ready = true;
	},

	update: function update() {
		if (this.ready) {
			this.serial.update();
			this.debug.update();
			this.mem.update();
		}
	},

	serial: {
		output: {
			outputTextArea: null,

			init: function init() {
				this.outputTextArea = util.getElem("serial_outputTextArea");

				this.clear();
			},

			clear: function clear() {
				this.outputTextArea.value = "";
			},

			putChar: function putChar(ch) {
				this.outputTextArea.value += ch;
			},
		},

		input: {
			inputTextElement: null,
			fifoTextAreaElement: null,

			init: function init() {
				this.inputTextElement = util.getElem("serial_inputText");
				this.fifoTextAreaElement = util.getElem("serial_fifoTextArea");

				let self = this;
				function doSend() {
					serial.input.putStr(self.inputTextElement.value);

					self.inputTextElement.value = "";

					self.update();
				};
				util.setOnKeydown("serial_inputText", function serial_inputText_keydown(kde) {
					if (kde.key === "Enter") {
						kde.preventDefault();
						doSend();
					}
				});
				util.setOnClick("serial_sendButton", doSend);

				this.update();
			},

			update: function update() {
				this.fifoTextAreaElement.value = serial.input.getFifoStr();
			},
		},

		init: function init() {
			this.output.init();
			this.input.init();
		},

		update: function update() {
			this.input.update();
		},
	},

	code: {
		editorElement: null,

		init: function init() {
			this.editorElement = util.getElem("code_editor");
		},
	},

	debug: {
		pcElement: null,
		stateElement: null,
		regElements: [],
		fileElement: null,

		init: function init() {
			this.pcElement = util.getElem("debug_pc");
			this.stateElement = util.getElem("debug_state");

			for (let i=0; i<16; i++) {
				let name = "debug_x" + i;
				let elem = util.getElem(name);
				this.regElements.push(elem);
			}

			this.update();
		},

		update: function update() {
			this.pcElement.innerText = util.hex32(cpu.pc);

			// TODO have "running" state
			if (cpu.haltSet) {
				this.stateElement.innerText = "halt";
				this.stateElement.classList.remove("warning");
				this.stateElement.classList.add("error");
			}
			else if (cpu.breakSet) {
				this.stateElement.innerText = "break";
				this.stateElement.classList.remove("error");
				this.stateElement.classList.add("warning");
			}
			else {
				this.stateElement.innerText = "";
				this.stateElement.classList.remove("warning");
				this.stateElement.classList.remove("error");
			}
			
			for (let i=0; i<16; i++) {
				this.regElements[i].innerText = util.hex32(cpu.x[i]);
			}
		},

		run: function run() {
			cpu.run();
		},

		brk: function brk() {
			cpu.brk();

			this.update();
		},

		reset: function reset() {
			cpu.reset();
			screen.reset();
			serial.reset();  // TODO clear serial UI on reset

			this.update();
		},

		stepInto: function stepInto() {
			cpu.step();

			this.update();
		},
	},

	mem: {
		displayTextAreaElement: null,
		blockNumTextInputElement: null,
		fileInputElement: null,

		block_size: 0x100,
		block_count: mem.ram_size / this.block_size,

		getBlockNum: function getBlockNum() {
			let num = parseInt(this.blockNumTextInputElement.value);
			if (isNaN(num)) {
				num = 0;
			}

			return num;
		},

		init: function init() {
			this.displayTextAreaElement = util.getElem("mem_displayTextArea");
			this.blockNumTextInputElement = util.getElem("mem_blockNumTextInput");
			this.fileInputElement = util.getElem("mem_fileInput");

			this.update();

			let self = this;
			util.setOnChange(this.blockNumTextInputElement, function mem_blockNumTextInput_onchange() {
				self.update(self.getBlockNum());
			});
			util.setOnChange(this.fileInputElement, function fileInput_onchange(ce) {
				const files = ce.target.files;
				if ( !files ) {
					console.log("ERROR: files was null");  // TODO UI error
					return;
				}
				if ( files.length < 1 ) {
					console.log("ERROR: files.length was " + files.length);  // TODO UI error
					return;
				}

				const file = files[0];
				if (file.size > mem.ram_size) {
					console.log("ERROR: file was too big");  // TODO UI error
					return;
				}

				const reader = new FileReader();
				reader.addEventListener("load", function load(le) {
					const data = le.target.result;
					mem.load(data);

					// TODO update screen
					self.update(0);
				});
				reader.readAsArrayBuffer(file);
			});
		},

		// TODO can enter too large of a number in input box
		update: function update(blockNum) {
			if (blockNum === undefined) {
				blockNum = this.getBlockNum();
			}

			if (blockNum < 0) {
				blockNum = 0;
			}
			else if (blockNum >= this.block_count) {
				blockNum = block_count - 1;
			}

			this.displayTextAreaElement.value = "";

			const start = blockNum * (this.block_size / 4);
			const end = start + (this.block_size / 4);
			const r = mem.ram;
			for (let i=start; i<end; i+=4) {
				if (i != start) {
					this.displayTextAreaElement.value += "\n";
				}

				this.displayTextAreaElement.value += util.hex32(i*4)
					+ ": "
					+ util.hex32(r[i+0])
					+ " "
					+ util.hex32(r[i+1])
					+ " "
					+ util.hex32(r[i+2])
					+ " "
					+ util.hex32(r[i+3])
				;
			}

			this.blockNumTextInputElement.value = blockNum.toString();
		},

		blockPrev: function blockPrev() {
			this.update(this.getBlockNum() - 1);
		},

		blockNext: function blockNext() {
			this.update(this.getBlockNum() + 1);
		},

		load: function load() {
			// TODO clear remaining memory after load
			this.fileInputElement.click();
		},
	},
};

window.onload = function onload() {
	mem.init();
	cpu.init();
	screen.init();
	serial.reset();

	ui.init();
}
</script>
<style>
* {
	background-color: black;
	color: white;
}

body {
	display: flex;
}

@media (orientation: landscape) {
	body {
		flex-direction: row;
	}
}

@media (orientation: portrait) {
	body {
		flex-direction: column;
	}
}

.monospace {
	font-family: monospace;
}

/* TODO screen is tiny */
#screen_canvas{
	/* nearest neighbor scaling */
	image-rendering: -webkit-optimize-contrast; /* webkit */
	image-rendering: -moz-crisp-edges; /* Firefox */

	width: 20em;
}

.debug_button {
	width: 8em;
}

.mem_button {  /* TODO more descriptive name? */
	width: 2em;
}

.warning {
	color: yellow;
	font-weight: bold;
}

.error {
	color: red;
	font-weight: bold;
}
</style>
<title>RV ASM</title>
</head>
<body>
	<div class="chunk">
		<canvas id="screen_canvas" height="64" width="64"></canvas>
	</div>

	<div class="chunk">
		<table>
			<tr><td> <textarea id="serial_outputTextArea" class="monospace" cols=40 rows=20 readonly title="Serial output"></textarea> </td></tr>
			<tr><td> <textarea id="serial_fifoTextArea" class="monospace" cols=40 rows=1 readonly title="Serial input FIFO state"></textarea> </td></tr>
			<tr><td>
				<input type="text" id="serial_inputText" class="monospace" spellcheck="false" title="Type serial input here" />
				<button id="serial_sendButton" title="Click to send serial input">Send</button>
			</td></tr>
		</table>
	</div>

	<div class="chunk">
		<textarea id="code_editor" cols=40 rows=20 spellcheck="false" class="monospace"></textarea>
	</div>

	<div class="chunk">
		<table class="monospace">
			<tr>
				<td rowspan=9><table>
					<tr><td> <button onclick="ui.debug.run()" class="debug_button" title="Run the code (F5)">Run</button> </td></tr>
					<tr><td> <button onclick="ui.debug.brk()" class="debug_button" title="Stop running the code (F8)">Break</button> </td></tr>
					<tr><td> <button onclick="ui.debug.reset()" class="debug_button" title="Reset the system (F9)">Reset</button> </td></tr>
					<tr><td> <button class="debug_button" title="Step to next instruction, but not into subroutines (F10)">Step over</button> </td></tr>
					<tr><td> <button onclick="ui.debug.stepInto()" class="debug_button" title="Step to next instruction (F11)">Step into</button> </td></tr>
				</table></td>
				<th>pc</th> <td id="debug_pc" />
				<th></th> <td id="debug_state" />
			</tr>
			<tr> <th>z</th>  <td id="debug_x0" /> <th>x8</th>  <td id="debug_x8"  /> </tr>
			<tr> <th>ra</th> <td id="debug_x1" /> <th>x9</th>  <td id="debug_x9"  /> </tr>
			<tr> <th>sp</th> <td id="debug_x2" /> <th>x10</th> <td id="debug_x10" /> </tr>
			<tr> <th>x3</th> <td id="debug_x3" /> <th>x11</th> <td id="debug_x11" /> </tr>
			<tr> <th>x4</th> <td id="debug_x4" /> <th>x12</th> <td id="debug_x12" /> </tr>
			<tr> <th>x5</th> <td id="debug_x5" /> <th>x13</th> <td id="debug_x13" /> </tr>
			<tr> <th>x6</th> <td id="debug_x6" /> <th>x14</th> <td id="debug_x14" /> </tr>
			<tr> <th>x7</th> <td id="debug_x7" /> <th>x15</th> <td id="debug_x15" /> </tr>
		</table>
	</div>

	<div class="chunk" id="mem">
		<table class="monospace">
			<tr><td> <textarea id="mem_displayTextArea" cols=45 rows=16 readonly></textarea> </td></tr>
			<tr><td>
				<input type="text" id="mem_blockNumTextInput" class="monospace" spellcheck="false" title="The current block of memory being displayed" />
				<button onclick="ui.mem.blockPrev()" class="mem_button" title="Previous block (F1)">-</button>
				<button onclick="ui.mem.blockNext()" class="mem_button" title="Next block (F2)">+</button>
				<button onclick="ui.mem.load()" title="Load binary file into memory (F4)">Load</button> <input type="file" id="mem_fileInput" style="display: none;" />
			</td></tr>
		</table>
	</div>

	<div class="chunk">
<textarea cols=40 rows=20 spellcheck="false" class="monospace" readonly>
========================================
            SPECIFICATIONS
========================================
CPU: RISC-V (RV32EM)
  - 32bit
  - 13 general purpose registers
  - multipliy, divide instructions
RAM: 1MiB
  - 20KiB reserved for IO
Screen:
  - 64x64 pixels
  - 24bit RGB
Sound:
  - 3 square waves
  - 1 noise
Gamepad:
  - D-pad
  - A, B, X, Y
  - Start
Timers
Serial terminal

========================================
            INSTRUCTION SET
========================================
Load:
lw    rd, off(rs) (rd = mem[rs+off])
lh    rd, off(rs) (16bit lw)
lhu   rd, off(rs) (unsigned lh)
lb    rd, off(rs) (8bit lw)
lbu   rd, off(rs) (unsigned lb)
(off is 12bit signed)
lui   rd, imm (rd = imm << 12)
auipc rd, imm (rd = PC + (imm << 12))
(imm is 20bit unsigned)

Store:
sw rs2, off(rs1) (mem[rs1+off] = rs2)
sh rs2, off(rs1) (16bit sw)
sb rs2, off(rs1) (8bit sw)
(off is 12bit signed)

Math:
add  rd, rs1, rs2 (rd = rs1 + rs2)
addi rd, rs1, imm (rd = rs1 + imm)
sub  rd, rs1, rs2 (rd = rs1 - rs2)
sra  rd, rs1, rs2 (rd = rs1 / 2^rs2)
srai rd, rs1, imm (rd = rs1 / 2^imm)
(imm is 12bit signed)

Bitmath:
and  rd, rs1, rs2 (rd = rs1 & rs2)
andi rd, rs1, imm (rd = rs1 & imm)
or   rd, rs1, rs2 (rd = rs1 | rs2)
ori  rd, rs1, imm (rd = rs1 | imm)
xor  rd, rs1, rs2 (rd = rs1 ^ rs2)
xori rd, rs1, imm (rd = rs1 ^ imm)
sll  rd, rs1, rs2 (rd = rs1 << rs2)
slli rd, rs1, imm (rd = rs1 << imm)
srl  rd, rs1, rs2 (rd = rs1 >> rs2)
srli rd, rs1, imm (rd = rs1 >> imm)
(imm is 12bit)

Compare:
slt   rd, rs1, rs2 (rd=(rs1<rs2)?1:0)
sltu  rd, rs1, rs2 (unsigned slt)
slti  rd, rs1, imm (rd=(rs1<imm)?1:0)
sltiu rd, rs1, imm (unsigned slti)
(imm is 12bit)

Branch:
beq  rs1, rs2, imm (rs1==rs2 ? PC+=imm)
bne  rs1, rs2, imm (rs1!=rs2 ? PC+=imm)
blt  rs1, rs2, imm (rs1<rs2 ? PC+=imm)
bltu rs1, rs2, imm (unsigned blt)
bge  rs1, rs2, imm (rs1>=rs2 ? PC+=imm)
bgeu rs1, rs2, imm (unsigned bge)
(imm is 13bit ?signed?, 16bit aligned)

Jump:
jal  rd, imm (rd=PC+4, PC+=imm)
(imm is 21bit ?signed?, 16bit aligned)
jalr rd, rs1, imm (PC+rs1 jal)
(imm is 12bit ?signed?)

Special:
ebreak (break)

========================================
          ASSEMBLER DIRECTIVES
========================================

========================================
               MEMORY MAP
========================================
0x00000-FAFFF Code
0xFB000-FEFFF screen framebuffer
0xFF000-FF0FF serial registers
0xFF100-FF1FF timer registers
0xFF200-FF2FF sound registers
0xFF300-FF3FF gamepad registers
0xFF400-FFFxx reserved
0xFFFxx-FFFFF interrupt vector addr.s

All registers are 32bit.

========================================
            SERIAL REGISTERS
========================================
0xFF000 control flags
  bit 4 -- input FIFO not empty flag
  bits 3-0 -- input FIFO interrupt
              threshold (set to 0 to
	      disable this interrupt)
0xFF004 read character (from input FIFO)
0xFF008 write character

========================================
            TIMER REGISTERS
========================================
0xFF100 control flags
  bit 1 -- enable timer interrupt
  bit 0 -- enable timer
0xFF104 timer value
0xFF108 timer compare value

========================================
            SOUND REGISTERS
========================================
0xFF200 control flags
0xFF2xx channel 1 frequency
0xFF2xx channel 1 volume
0xFF2xx channel 2 frequency
0xFF2xx channel 2 volume
0xFF2xx channel 3 frequency
0xFF2xx channel 3 volume
0xFF2xx noise volume
0xFF2xx noise frequency

========================================
           GAMEPAD REGISTERS
========================================
0xFF300 control flags
0xFF304 state
  bit 8 - Start (Enter key)
  bit 7 - Y button (S key)
  bit 6 - X button (A key)
  bit 5 - B button (X key)
  bit 4 - A button (Z key)
  bit 3 - Right
  bit 2 - Left
  bit 1 - Down
  bit 0 - Up
0xFF308 prior state
</textarea>
	</div>

</body>
</html>
