<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" >
<!-- 2020 David DiPaola. Licensed under CC0 (https://creativecommons.org/share-your-work/public-domain/cc0/). -->
<title>RV ASM</title>
<style>
* {
	background-color: black;
	color: white;
}

body {
	display: flex;
}

@media (orientation: landscape) {
	body {
		flex-direction: row;
	}
}

@media (orientation: portrait) {
	body {
		flex-direction: column;
	}
}

.monospace {
	font-family: monospace;
}

/* TODO screen is tiny */
#rvcanvas {
	/* nearest neighbor scaling */
	image-rendering: -webkit-optimize-contrast; /* webkit */
	image-rendering: -moz-crisp-edges /* Firefox */
}

.rvdebug_button {
	width: 8em;
}

.rvmem_button {
	width: 2em;
}
</style>
<script>
/* @license magnet:?xt=urn:btih:90dc5c0be029de84e523b9b3922520e79e0e6f08&dn=cc0.txt CC0 */

let util = {
	hex32: function hex32(val) {
		return ("00000000" + val.toString(16)).substr(-8).toUpperCase();
	},
};

let rvemu = {
	pc: 0,
	x: null,
	mem: null,
	mem_size: 1 * 1024 * 1024,

	init: function init() {
		this.x = new Uint32Array(16);

		this.mem = new Uint32Array(this.mem_size / 4);
	},

	load: function load(buffer) {
		/* TODO endianness */
		const input = new Uint32Array(buffer);
		for (let i=0; i<input.length; i++) {
			this.mem[i] = input[i];
		}

		rvmem.update();
	},
};

let rvscreen = {
	canvas: null,
	context: null,
	width: 0,
	height: 0,

	init: function init() {
		this.canvas = document.getElementById("rvcanvas");
		if (!this.canvas) {
			console.log("ERROR: can't find canvas element");
			return;
		}

		this.context = this.canvas.getContext("2d");
		this.width = this.canvas.width;
		this.height = this.canvas.height;

		this.context.clearRect(0, 0, this.width, this.height);
	},

	/* TODO use rvemu.mem */

	newBuffer: function newBuffer() {
		return new Uint32Array(this.width * this.height);
	},

	set: function set(buffer) {
		let imgd = this.context.createImageData(this.width, this.height);
		for (let i=0; i<imgd.data.length; i+=4) {
			let pixel = buffer[i/4];
			imgd.data[i+0] = (pixel>>16) & 0xFF;
			imgd.data[i+1] = (pixel>> 8) & 0xFF;
			imgd.data[i+2] = (pixel>> 0) & 0xFF;
			imgd.data[i+3] = 0xFF;
		}
		this.context.putImageData(imgd, 0, 0);
	},
};

let rvserial = {
	output: {
		element: null,

		init: function init() {
			this.element = document.getElementById("rvserial_output");
			if (!this.element) {
				console.log("ERROR: can't find rvserial textarea output element");
				return;
			}

			this.clear();
		},

		clear: function clear() {
			this.element.value = "";
		},

		put: function put(ch) {
			this.element.value += String.fromCharCode(ch);
		},
	},

	input: {
		inputElement: null,
		fifoElement: null,
		buffer: [],
		empty: true,

		init: function init() {
			this.inputElement = document.getElementById("rvserial_input");
			if (!this.inputElement) {
				console.log("ERROR: can't find rvserial input element");
				return;
			}

			this.fifoElement = document.getElementById("rvserial_fifo");
			if (!this.fifoElement) {
				console.log("ERROR: can't find rvserial FIFO element");
				return;
			}
			this.fifoElement.value = "";
		},

		put: function put(ch) {
			this.buffer.push(ch);

			this.empty = false;

			this.showFifo();
		},

		get: function get() {
			let ch = 0;

			if (this.buffer.length != 0) {
				let str = this.buffer.shift();
				ch = str.charCodeAt(0);

				if (this.buffer.length == 0) {
					this.empty = true;
				}
			}

			this.showFifo();

			return ch;
		},

		onsend: function onsend() {
			let str = this.inputElement.value;
			for (let i=0; i<str.length; i++) {
				this.put(str[i]);
			}

			this.inputElement.value = "";
		},

		showFifo: function showFifo() {
			let str = "";
			for (let i=0; i<this.buffer.length; i++) {
				str += this.buffer[i];
			}

			this.fifoElement.value = str;
		},
	},

	init: function init() {
		this.output.init();
		this.input.init();
	},
	
	put: function put(ch) {
		this.output.put(ch);
	},

	get: function get() {
		return this.input.get();
	},

	onsend: function onsend() {
		this.input.onsend();
	},
};

let rvcode = {
	element: null,

	init: function init() {
		this.element = document.getElementById("rvcode");
		if (!this.element) {
			console.log("ERROR: can't find rvcode textarea element");
			return;
		}
	},

	get: function get() {
		return this.element.value;
	},
};

let rvdebug = {
	pcElement: null,
	regElements: [],
	fileElement: null,

	init: function init() {
		this.pcElement = document.getElementById("rvdebug_pc");
		if (!this.pcElement) {
			console.log("ERROR: can't find rvdebug_pc element");
			return;
		}

		for (let i=0; i<16; i++) {
			let name = "rvdebug_x" + i;
			let elem = document.getElementById(name);
			if (!elem) {
				console.log("ERROR: can't find "+name+" element");
				return;
			}

			this.regElements.push(elem);
		}

		this.fileElement = document.getElementById("rvdebug_file");
		if (!this.fileElement) {
			console.log("ERROR: can't find rvdebug_file element");
			return;
		}
		this.fileElement.addEventListener("change", this.onFileElementChange);

		this.update();
	},

	update: function update() {
		this.pcElement.innerText = util.hex32(rvemu.pc);
		
		for (let i=0; i<16; i++) {
			this.regElements[i].innerText = util.hex32(rvemu.x[i]);
		}
	},

	onFileElementChange: function onFileElementChange(ce) {
		const files = event.target.files;
		if ( !files ) {
			console.log("ERROR: files was null");
			return;
		}
		if ( files.length < 1 ) {
			console.log("ERROR: files.length was " + files.length);
			return;
		}

		const file = files[0];
		if (file.size > rvemu.mem_size) {
			console.log("ERROR: file was too big");
			return;
		}
		const reader = new FileReader();
		reader.addEventListener("load", function load(le) {
			const data = le.target.result;
			rvemu.load(data);
		});
		reader.readAsArrayBuffer(file);
	},
};

let rvmem = {
	displayElement: null,
	blockElement: null,
	block_size: 0x100,
	block_count: rvemu.mem_size / this.block_size,

	init: function init() {
		this.displayElement = document.getElementById("rvmem_display");
		if (!this.displayElement) {
			console.log("ERROR: can't find rvmem element");
			return;
		}

		this.blockElement = document.getElementById("rvmem_block");
		if (!this.blockElement) {
			console.log("ERROR: can't find rvmem block element");
			return;
		}
		this.blockElement.value = "0";
		
		this.update(0);
	},

	update: function update(block) {
		if (block === undefined) {
			block = parseInt(this.blockElement.value);
		}
		else if (block < 0) {
			block = 0;
		}
		else if (block >= this.block_count) {
			block = block_count - 1;
		}

		this.displayElement.value = "";

		const start = block * (this.block_size / 4);
		const end = start + (this.block_size / 4);
		const m = rvemu.mem;
		for (let i=start; i<end; i+=4) {
			if (i != start) {
				this.displayElement.value += "\n";
			}

			this.displayElement.value += util.hex32(i*4)
				+ ": "
				+ util.hex32(m[i+0])
				+ " "
				+ util.hex32(m[i+1])
				+ " "
				+ util.hex32(m[i+2])
				+ " "
				+ util.hex32(m[i+3])
			;
		}

		this.blockElement.value = block.toString();
	},

	block_onchange: function block_onchange() {
		let block = parseInt(this.blockElement.value);
		this.update(block);
	},

	down_onclick: function down_onlcick() {
		let block = parseInt(this.blockElement.value);
		this.update(block - 1);
	},

	up_onclick: function up_onlcick() {
		let block = parseInt(this.blockElement.value);
		this.update(block + 1);
	},
};


window.onload = function onload() {
	rvemu.init();
	rvscreen.init();
	rvserial.init();
	rvdebug.init();
	rvmem.init();

	let buffer = rvscreen.newBuffer();
	buffer[0] = 0xFF00FF;
	rvscreen.set(buffer);

	rvserial.put(0x45);
}
</script>
</head>
<body>
	<div class="chunk">
		<canvas id="rvcanvas" height="64" width="64"></canvas>
	</div>

	<div class="chunk">
		<table>
			<tr><td colspan=2> <textarea id="rvserial_output" class="monospace" cols=40 rows=20 readonly title="Serial output"></textarea> </td></tr>
			<tr><td colspan=2> <textarea id="rvserial_fifo" class="monospace" cols=40 rows=1 readonly title="Serial input FIFO state"></textarea> </td></tr>
			<tr>
				<td> <input type="text" id="rvserial_input" class="monospace" title="Type serial input here" /> </td>
				<td> <button onclick="rvserial.onsend()" title="Click to send serial input">Send</button> </td>
			</tr>
		</table>
	</div>

	<div class="chunk">
		<textarea id="rvcode" cols=40 rows=20 spellcheck="false" class="monospace"></textarea>
	</div>

	<div class="chunk">
		<table class="monospace">
			<tr>
				<td rowspan=9><table>
					<tr><td> <button class="rvdebug_button" title="Run the code (F5)">Run</button> </td></tr>
					<tr><td> <button class="rvdebug_button" title="Stop running the code (F8)">Break</button> </td></tr>
					<tr><td> <button class="rvdebug_button" title="Reset the system (F9)">Reset</button> </td></tr>
					<tr><td> <button class="rvdebug_button" title="Step to next instruction, but not into subroutines (F10)">Step over</button> </td></tr>
					<tr><td> <button class="rvdebug_button" title="Step to next instruction (F11)">Step into</button> </td></tr>
					<tr><td>
						<input type="file" id="rvdebug_file" style="display: none;" />
						<button class="rvdebug_button" onclick="document.getElementById('rvdebug_file').click();" title="Load binary file into memory">Load</button>
					</td></tr>
				</table></td>
				<th>pc</th> <td id="rvdebug_pc" />
			</tr>
			<tr> <th>z</th>  <td id="rvdebug_x0" /> <th>x8</th>  <td id="rvdebug_x8"  /> </tr>
			<tr> <th>ra</th> <td id="rvdebug_x1" /> <th>x9</th>  <td id="rvdebug_x9"  /> </tr>
			<tr> <th>sp</th> <td id="rvdebug_x2" /> <th>x10</th> <td id="rvdebug_x10" /> </tr>
			<tr> <th>x3</th> <td id="rvdebug_x3" /> <th>x11</th> <td id="rvdebug_x11" /> </tr>
			<tr> <th>x4</th> <td id="rvdebug_x4" /> <th>x12</th> <td id="rvdebug_x12" /> </tr>
			<tr> <th>x5</th> <td id="rvdebug_x5" /> <th>x13</th> <td id="rvdebug_x13" /> </tr>
			<tr> <th>x6</th> <td id="rvdebug_x6" /> <th>x14</th> <td id="rvdebug_x14" /> </tr>
			<tr> <th>x7</th> <td id="rvdebug_x7" /> <th>x15</th> <td id="rvdebug_x15" /> </tr>
		</table>
	</div>

	<div class="chunk" id="rvmem">
		<table class="monospace">
			<tr><td> <textarea id="rvmem_display" cols=45 rows=16 readonly></textarea> </td></tr>
			<tr><td>
				<textarea id="rvmem_block" cols=10 rows=1 onchange="rvmem.block_onchange()" title="The current block of memory being displayed"></textarea>
				<button onclick="rvmem.down_onclick()" class="rvmem_button" title="Previous block (F1)">-</button>
				<button onclick="rvmem.up_onclick()" class="rvmem_button" title="Next block (F2)">+</button>
			</td></tr>
		</table>
	</div>

	<div class="chunk">
<textarea cols=40 rows=20 spellcheck="false" class="monospace" readonly>
========================================
            SPECIFICATIONS
========================================
CPU: RISC-V (RV32EM)
  - 32bit
  - 13 general purpose registers
  - multipliy, divide instructions
RAM: 1MiB
  - 20KiB reserved for IO
Screen:
  - 64x64 pixels
  - 24bit RGB
Sound:
  - 3 square waves
  - 1 noise
Gamepad:
  - D-pad
  - A, B, X, Y
  - Start
Timers
Serial terminal

========================================
            INSTRUCTION SET
========================================
Load:
lw    rd, off(rs) (rd = mem[rs+off])
lh    rd, off(rs) (16bit lw)
lhu   rd, off(rs) (unsigned lh)
lb    rd, off(rs) (8bit lw)
lbu   rd, off(rs) (unsigned lb)
(off is 12bit signed)
lui   rd, imm (rd = imm << 12)
auipc rd, imm (rd = PC + (imm << 12))
(imm is 20bit unsigned)

Store:
sw rs2, off(rs1) (mem[rs1+off] = rs2)
sh rs2, off(rs1) (16bit sw)
sb rs2, off(rs1) (8bit sw)
(off is 12bit signed)

Math:
add  rd, rs1, rs2 (rd = rs1 + rs2)
addi rd, rs1, imm (rd = rs1 + imm)
sub  rd, rs1, rs2 (rd = rs1 - rs2)
sra  rd, rs1, rs2 (rd = rs1 / 2^rs2)
srai rd, rs1, imm (rd = rs1 / 2^imm)
(imm is 12bit signed)

Bitmath:
and  rd, rs1, rs2 (rd = rs1 & rs2)
andi rd, rs1, imm (rd = rs1 & imm)
or   rd, rs1, rs2 (rd = rs1 | rs2)
ori  rd, rs1, imm (rd = rs1 | imm)
xor  rd, rs1, rs2 (rd = rs1 ^ rs2)
xori rd, rs1, imm (rd = rs1 ^ imm)
sll  rd, rs1, rs2 (rd = rs1 << rs2)
slli rd, rs1, imm (rd = rs1 << imm)
srl  rd, rs1, rs2 (rd = rs1 >> rs2)
srli rd, rs1, imm (rd = rs1 >> imm)
(imm is 12bit)

Compare:
slt   rd, rs1, rs2 (rd=(rs1<rs2)?1:0)
sltu  rd, rs1, rs2 (unsigned slt)
slti  rd, rs1, imm (rd=(rs1<imm)?1:0)
sltiu rd, rs1, imm (unsigned slti)
(imm is 12bit)

Branch:
beq  rs1, rs2, imm (rs1==rs2 ? PC+=imm)
bne  rs1, rs2, imm (rs1!=rs2 ? PC+=imm)
blt  rs1, rs2, imm (rs1<rs2 ? PC+=imm)
bltu rs1, rs2, imm (unsigned blt)
bge  rs1, rs2, imm (rs1>=rs2 ? PC+=imm)
bgeu rs1, rs2, imm (unsigned bge)
(imm is 13bit ?signed?, 16bit aligned)

Jump:
jal  rd, imm (rd=PC+4, PC+=imm)
(imm is 21bit ?signed?, 16bit aligned)
jalr rd, rs1, imm (PC+rs1 jal)
(imm is 12bit ?signed?)

Special:
ebreak (break)

========================================
          ASSEMBLER DIRECTIVES
========================================

========================================
               MEMORY MAP
========================================
0x00000-FAFFF Code
0xFB000-FEFFF screen framebuffer
0xFF000-FF0FF serial registers
0xFF100-FF1FF timer registers
0xFF200-FF2FF sound registers
0xFF300-FF3FF gamepad registers
0xFF400-FFFxx reserved
0xFFFxx-FFFFF interrupt vector addr.s

All registers are 32bit.

========================================
            SERIAL REGISTERS
========================================
0xFF000 control flags
  bit 4 -- input FIFO not empty flag
  bits 3-0 -- input FIFO interrupt
              threshold (set to 0 to
	      disable this interrupt)
0xFF004 read character (from input FIFO)
0xFF008 write character

========================================
            TIMER REGISTERS
========================================
0xFF100 control flags
  bit 1 -- enable timer interrupt
  bit 0 -- enable timer
0xFF104 timer value
0xFF108 timer compare value

========================================
            SOUND REGISTERS
========================================
0xFF200 control flags
0xFF2xx channel 1 frequency
0xFF2xx channel 1 volume
0xFF2xx channel 2 frequency
0xFF2xx channel 2 volume
0xFF2xx channel 3 frequency
0xFF2xx channel 3 volume
0xFF2xx noise volume
0xFF2xx noise frequency

========================================
           GAMEPAD REGISTERS
========================================
0xFF300 control flags
0xFF304 state
  bit 8 - Start (Enter key)
  bit 7 - Y button (S key)
  bit 6 - X button (A key)
  bit 5 - B button (X key)
  bit 4 - A button (Z key)
  bit 3 - Right
  bit 2 - Left
  bit 1 - Down
  bit 0 - Up
0xFF308 prior state
</textarea>
	</div>

</body>
</html>
